<html>
<head><title>ProgDB Help - Basic Concepts</title></head>
<body>
<h2>Basic Concepts</h2>
<H3>Rooms, People and Items</h3>
<p>
The three core concepts of the progdb are rooms, people and items:
<ul>
<li> <em>Rooms</em> are the physical rooms within the venue, where con stuff takes place.
They can be subdivided, be listed on programme booklet grids or be private, have certain layouts and capacities,
and so on.</li>
<li> <em>People</em> are the named participants of programme items. Panel members, moderators,
quiz master, and so on.</li>
<li> <em>Items</em> are the scheduled events in the programme: the Opening Ceremony would be
one, as would Torchwood Wobblevision. Items occur in a particular <em>Room</em> at a
particular time, for a given duration, and can have <em>people</em> associated with them, in
various roles.
</ul>
</p>
<p>
Generally, speaking, you start off with a database that contains a load of pre-configured
Rooms (set up by Steve K), and no Items or People. You enter items and people separately,
then you assign people to items, and assign items to rooms and to timeslots in the programme.
</p>

<h3>Grids and slots</h3>
<p>
An item could theoretically start at any time, but the database comes pre-configured with
a known-grid of timeslots. There's a day for each day of the con, and each of those days
has hour-long slots running from 9am on the morning of that day, to 1am on the morning of
the following day (adopting approximately the Redemption convention of running a programme day for 16 hours
from 10am to 2am). There are also pre-configured item durations, e.g. half an hour, one hour,
two hours or three hours. Note that these are the <em>pre-configured</em> choices - if you
need a greater variety, or longer or shorter items, that can be done.
</p>

<p>
The database also knows about non-public days of the con - those days before the con starts
and those days after the con ends.
</p>

<p>
Another concept taken from Redemption is the <em>Grid</em>. The Redemption programme booklet
lists the programme in four-hour chunks, e.g. Friday 2pm-6pm, Friday 6pm-10pm. The database
has a similar concept, in that it has pre-configured chunks of four-hour periods for displaying
items in a grid format. <em>This is just for presentation purposes</em>, because if you
keep asking the database to display six days worth of grid, there's a lot of scrolling in your
browser.
</p>

<p>
(I'd like to think that the grids could translate directly into README data, but we'll see.)
</p>

<h3>Tags</h3>
<p>
Tags are an arbitrary linking system. The assumption is that you're occasionally going to want
to, say, find all items relating to Star Trek, or all items that are about movies, or all
the committee members, or all the guests, and so on.
</p>

<p>
Tags are very simple: they have a name and a description, and you can add as many as you want.
Then they can be assigned to people, and to programme items. When you look at a programme item,
you see the tags associated with it. You can follow a given tag to see all the other programme
items with that tag, or all the people that have it.
</p>

<p>
(I'd hope that the tags are a public thing on a live, readable version of the programme, but
maybe not...)
</p>

<H3>Tech</h3>
<p>
This, I'm told, should really be called "stuff", because that's what it is. It's the physical
things that get moved from room to room as required. Microphones, laptops, screens, flip-charts,
and so on. Each tech item has a name, plus other details, and can be associated with programme
items. Then you can find out how many programme items need that piece of tech, and you can
get a listing of all the tech you need, for all items.
</p>

<p>
Yes, "Tech" was a bad choice of name for this. I'm sorry. Let's move on.
</p>

<h3>Data entry and checking</h3>
<p>
The philosophy here is that programmes develop over time, and that you don't create a programme
in its final state immediately. You'll hear about ideas for programme items, and have vague
thoughts as to who'd be involved, but you don't know all the people when you first enter the
programme item into the database. Nor do you usually know which room it'll be in, or in which
time-slot.
</p>

<p>
It's also assumed that, periodically, you'll have to go through hefty periods of rearrangement:
Bob can't make Saturday, so his items all have to move, and now the fireworks display can't be
in the main hall, and that means the cold fusion demonstration has to get bumped to another slot,
and so on. Chances are, while you're moving things around, you'll be continually creating
programmes that are "inconsistent" - two items in the same room, or the same person being assigned
to two different programme items in different rooms at the same time. These are okay; it's assumed
that you'll move A to B, then X to Y, where the first action creates a conflict, and the second
fixes it.
</p>

<p>
Because of this expectation, the database doesn't continually check whether each action creates
a problem. Instead, the assumption is that, once you've finished, you can tell the database,
"please let me know about any problems," and <em>then</em> the database will furtle through all
your info and see what's what.
</p>

<p>
(Also, the kind of checks we're talking about are computationally expensive, since everything
has to be checked against everything else, and that's not something you want to have happen every
time you make a little change.)
</p>

<h3>Other bits</h3>
<p>
This page has just touched on the main concepts of the progdb. There are other things that'll be
introduced at the appropriate time. So don't be thinking, "harmuph, I need feature X, and there's
been no mention of it yet!" Because there's a lot that hasn't been mentioned yet. Be patient.
</p>
</body>
</html>
